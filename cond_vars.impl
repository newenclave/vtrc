
struct answer_type {
    boost::condition_variable cond_;
    int result_;
};

typedef std::map<unsigned, boost::shared_ptr<answer_type> > answer_map;
typedef boost::mutex answer_lock_type;

answer_map       gmap;
answer_lock_type glock;

void read_response( unsigned id )
{
    boost::unique_lock<answer_lock_type> l(glock);
    answer_map::iterator f(gmap.find(id));
    if(f != gmap.end( )) {
        boost::shared_ptr<answer_type> result = f->second;
        bool to = result->cond_.wait_for( l, boost::chrono::milliseconds(20000));
        if( to ) {
            std::cout << "timeout " << id << "\n";
        } else {
            std::cout << "ready " << id << " " << result->result_ << "\n";
            sleep(1);
        }
    } else {
        std::cout << "request not found " << id << "\n";
    }
}

void add_request( unsigned id )
{
    boost::unique_lock<answer_lock_type> l(glock);
    std::cout << "add new request " << id << "\n";
    gmap.insert(std::make_pair(id, boost::make_shared<answer_type>( )));
}

void add_response( unsigned id, int result )
{
    boost::unique_lock<answer_lock_type> l(glock);
    answer_map::iterator f(gmap.find(id));
    if(f != gmap.end( )) {
        std::cout << "add new response " << id << "\n";
        f->second->result_ = result;
        f->second->cond_.notify_all( );
        gmap.erase( id );
    }
}

void clean_all( )
{
    boost::unique_lock<answer_lock_type> l(glock);
    for( answer_map::iterator b(gmap.begin()), e(gmap.end()); b!=e; ++b ) {
        b->second->result_ = -1;
        b->second->cond_.notify_all( );
        sleep(1);
    }
    gmap.clear( );
}

int main( )
{
    boost::thread_group tg;

    add_request( 0 );
    add_request( 2 );
    add_request( 3 );
    add_request( 4 );

    std::cout << "requests: " << gmap.size( ) << "\n";

    tg.add_thread( new boost::thread( boost::bind( read_response, 0 ) ) );
    std::cout << "start 0\n";
    tg.add_thread( new boost::thread( boost::bind( read_response, 1 ) ) );
    std::cout << "start 1\n";
    tg.add_thread( new boost::thread( boost::bind( read_response, 2 ) ) );
    std::cout << "start 2\n";
    tg.add_thread( new boost::thread( boost::bind( read_response, 3 ) ) );
    std::cout << "start 3\n";
    tg.add_thread( new boost::thread( boost::bind( read_response, 4 ) ) );
    std::cout << "start 4\n";

    sleep( 2 );
//    add_response( 2, 100 );
//    add_response( 3, 300 );

    sleep( 4 );
    //add_response( 0, 0 );

    add_request( 5 );
    tg.add_thread( new boost::thread( boost::bind( read_response, 5 ) ) );
    tg.add_thread( new boost::thread( boost::bind( read_response, 5 ) ) );
    std::cout << "start 5\n";

    sleep(3);

    clean_all( );

    //add_response( 5, -1 );

    tg.join_all( );

    std::cout << "end requests: " << gmap.size( ) << "\n";
    return 0;

}
